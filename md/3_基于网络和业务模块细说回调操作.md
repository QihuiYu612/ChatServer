# 3_基于网络和业务模块细说回调操作

回调操作被用于将网络层接收到的消息转发到业务层进行处理。这个机制使得网络层和业务层完全解耦，从而提高代码的可维护性和可扩展性。

### 详细说明回调操作

#### 回调的基本概念

回调是指将一个函数作为参数传递给另一个函数，以便在后者完成特定任务后调用前者。回调函数常用于异步操作、事件处理和解耦逻辑等场景。

### 示例中的回调操作

#### 1. 注册消息处理器

在 `ChatService` 的构造函数中，使用 `std::bind` 将消息类型（如 `LOGIN_MSG`、`REG_MSG`、`ONE_CHAT_MSG`）与对应的处理函数绑定，并存储在 `_msgHandlerMap` 中。

```
ChatService::ChatService() {
    _msgHandlerMap.insert({LOGIN_MSG, std::bind(&ChatService::login, this, _1, _2, _3)});
    _msgHandlerMap.insert({REG_MSG, std::bind(&ChatService::reg, this, _1, _2, _3)});
    _msgHandlerMap.insert({ONE_CHAT_MSG, std::bind(&ChatService::oneChat, this, _1, _2, _3)});
}
```

这里的 `_msgHandlerMap` 是一个 `unordered_map`，用于存储消息类型与处理函数的映射关系。`std::bind` 用于生成一个绑定了 `ChatService` 实例及其成员函数的可调用对象。

#### 2. 消息处理流程

当网络层接收到消息时，执行以下流程：

1. **从缓冲区读取数据**：

   ```
   string buf = buffer->retrieveAllAsString();
   ```

2. **反序列化数据**：

   ```c++
   json js = json::parse(buf);
   ```

3. **通过消息 ID 获取对应的处理函数**：

   ```c++
   auto msgHandler = ChatService::instance()->getHandler(js["msgid"].get<int>());
   ```

4. **调用处理函数**：

   ```C++
   msgHandler(conn, js, time);
   ```

### 具体的回调操作示例

假设接收到的消息类型为 `LOGIN_MSG`：

```c++
// 网络层接收到消息，经过反序列化，获取消息ID
int msgid = js["msgid"].get<int>();

// 通过消息ID获取对应的处理函数
auto msgHandler = ChatService::instance()->getHandler(msgid);

// 调用处理函数，执行登录业务逻辑
msgHandler(conn, js, time);
```

在 `ChatService` 中，`getHandler` 方法根据消息 ID 返回相应的处理函数：

```c++
MsgHandler ChatService::getHandler(int msgid) {
    auto it = _msgHandlerMap.find(msgid);
    if (it != _msgHandlerMap.end()) {
        return it->second;
    } else {
        // 处理未找到消息ID的情况
        return [](const TcpConnectionPtr &conn, json &js, Timestamp time) {
            // 处理未知消息
        };
    }
}
```

`_msgHandlerMap` 中存储的处理函数如下所示：

```c++
cpp
复制代码
_msgHandlerMap.insert({LOGIN_MSG, std::bind(&ChatService::login, this, _1, _2, _3)});
```

当处理函数被调用时，如 `login` 方法：

```c++
cpp复制代码void ChatService::login(const TcpConnectionPtr &conn, json &js, Timestamp time) {
    // 执行登录业务逻辑
}C
```

### 总结

- **回调注册**：在 `ChatService` 的构造函数中，使用 `std::bind` 将消息类型与对应的业务处理函数绑定，并存储在 `_msgHandlerMap` 中。
- **消息处理**：网络层接收到消息后，通过消息 ID 查找对应的处理函数，并调用该函数进行业务处理。
- **解耦**：这种设计实现了网络层和业务层的完全解耦，使得网络层无需了解业务层的具体实现，业务层也无需处理网络相关的代码，从而提高了代码的可维护性和可扩展性。